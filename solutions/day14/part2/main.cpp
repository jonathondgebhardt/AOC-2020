#include <day14/Utilities.ipp>

#include <algorithm>
#include <utility>

// File auto-generated by StartNewDay

struct MaskingStrategy_Part2 : util::day14::MaskingStrategy
{
  MaskingStrategy_Part2(const std::string& mask) : util::day14::MaskingStrategy(mask) {}

  void writeWordToMemory(util::day14::Word& word,
                         std::unordered_map<int64_t, util::day14::Word>& memory)
  {

    const auto addressCombos = this->getAddressCombinations(word.location);

    // At each location, write the same value
    for(const auto& combo : addressCombos)
    {
      const auto comboDecimal = util::day14::GetDecimalValue(combo);
      word.location = comboDecimal;
      memory[comboDecimal] = word;
    }
  }

  std::vector<std::array<char, 36>> getAddressCombinations(int64_t location)
  {
    const auto locationStr = std::bitset<36>(location).to_string();

    // Convert location to binary array
    std::array<char, 36> floatingAddress;
    floatingAddress.fill('0');
    for(int i = locationStr.size() - 1; i >= 0; --i)
    {
      floatingAddress[i] = locationStr[i];
    }

    // Apply mask to binary location
    std::vector<size_t> indexes;
    for(size_t i = 0; i < this->mask.size(); ++i)
    {
      // If the bitmask bit is 0, the corresponding memory address bit is unchanged.
      // If the bitmask bit is 1, the corresponding memory address bit is overwritten with 1.
      // If the bitmask bit is X, the corresponding memory address bit is floating.
      if(this->mask[i] != '0')
      {
        floatingAddress[i] = this->mask[i];

        // Track where the Xs are in the number to write to later.
        if(this->mask[i] == 'X')
        {
          indexes.push_back(i);
        }
      }
    }

    // Get combinations using the count of Xs as the sample space.
    // e.g.:
    // 2 'X's => {{0,0}, {0,1}, {1,0}, {1,1}}
    const auto combos = this->getCombinations(indexes.size());

    // Apply each combination to the floating address. Each X in the address will be replaced with a
    // combination that we found previously.
    std::vector<std::array<char, 36>> addressCombos;
    for(const auto& combo : combos)
    {
      auto addressCopy = floatingAddress;
      for(size_t i = 0; i < combo.size(); ++i)
      {
        addressCopy[indexes[i]] = combo[i];
      }

      addressCombos.push_back(addressCopy);
    }

    return addressCombos;
  }

  // https://stackoverflow.com/questions/14632555/algorithm-to-generate-all-possible-combinations-of-0s-1s-for-any-length-of-di
  std::vector<std::vector<char>> getCombinations(size_t sampleSpace)
  {
    std::vector<std::vector<char>> combos;

    constexpr auto zeroAscii = 48;

    size_t n = 1 << sampleSpace;
    for(size_t i = 0; i < n; ++i)
    {
      std::vector<char> combo;

      int bit = 1 << (sampleSpace - 1);
      while(bit)
      {
        const auto num = i & bit ? 1 : 0;
        combo.push_back(num + zeroAscii);

        bit >>= 1;
      }

      combos.push_back(combo);
    }

    return combos;
  }
};

int main(int argc, char* argv[])
{
  const auto inputFile = util::GetInputFile("day14.txt");
  const auto contents = util::Parse(inputFile);

  util::day14::Program<MaskingStrategy_Part2> p;
  p.execute(contents);

  std::cout << p.sumMemory() << "\n";

  return EXIT_SUCCESS;
}
