#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <bitset>
#include <cassert>
#include <cmath>
#include <memory>
#include <numeric>
#include <unordered_map>

namespace util
{
  namespace day14
  {
    int64_t UTILITIES_EXPORT GetDecimalValue(const std::array<char, 36> x)
    {
      int64_t decimalValue = 0;

      for(int i = 0, j = x.size() - 1; i < x.size(); ++i, --j)
      {
        if(x[j] == '1')
        {
          decimalValue += std::pow(2, i);
        }
      }

      return decimalValue;
    }

    struct UTILITIES_EXPORT Word
    {
      Word() { this->value.fill('0'); }

      explicit Word(int64_t location, int64_t value) : Word()
      {
        this->location = location;

        std::string binary = std::bitset<36>(value).to_string();
        for(int i = binary.size() - 1; i >= 0; --i)
        {
          this->value[i] = binary[i];
        }
      }

      int64_t operator+(int64_t otherValue) const
      {
        return GetDecimalValue(this->value) + otherValue;
      }

      void dump(std::ostream& os) const
      {
        os << "[" << this->location << "] = ";

        for(size_t i = 0; i < this->value.size(); ++i)
        {
          os << this->value[i];
        }

        os << "(" << GetDecimalValue(this->value) << ")";
        os << "\n";
      }

      int64_t location;
      std::array<char, 36> value;
    };

    struct UTILITIES_EXPORT MaskingStrategy
    {
      MaskingStrategy(const std::string& mask) : mask(mask) { assert(mask.size() == 36); }

      virtual void writeWordToMemory(Word& word, std::unordered_map<int64_t, Word>& memory) = 0;

      std::string mask;
    };

    template <typename T> struct UTILITIES_EXPORT Program
    {
      void execute(const std::vector<std::string>& x)
      {
        std::unique_ptr<T> maskingStrategy;

        for(const auto& line : x)
        {
          if(line.find("mask") != std::string::npos)
          {
            maskingStrategy = std::make_unique<T>(this->stringToMask(line));
          }
          else
          {
            auto w = this->stringToWord(line);
            maskingStrategy->writeWordToMemory(w, this->memory);
          }
        }
      }

      uint64_t sumMemory() const
      {
        uint64_t sum = 0;

        for(const auto& m : this->memory)
        {
          sum += GetDecimalValue(m.second.value);
        }

        return sum;
      }

      Word stringToWord(const std::string& x)
      {
        const auto open = x.find("[");
        const auto close = x.find("]");
        const auto location =
            util::StringTo<int64_t>(x.substr(open + 1, (close - open) - 1)).value();

        const auto equalsIndex = x.find("=");
        const auto rhs = x.substr(equalsIndex + 2);
        const auto value = util::StringTo<int64_t>(rhs).value();

        return Word(location, value);
      }

      std::string stringToMask(const std::string& x)
      {
        const auto equalsIndex = x.find("=");
        return x.substr(equalsIndex + 2);
      }

      void dump(std::ostream& os)
      {
        for(const auto& m : this->memory)
        {
          m.second.dump(os);
        }
      }

      std::unordered_map<int64_t, Word> memory;
    };

  } // namespace day14
} // namespace util
