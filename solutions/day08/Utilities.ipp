#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>

namespace util
{
  namespace day08
  {
    enum UTILITIES_EXPORT InstructionType
    {
      UNKNOWN = 0,
      NOP,
      ACC,
      JMP
    };

    InstructionType UTILITIES_EXPORT StringToInstructionType(const std::string& x)
    {
      auto instType = InstructionType::UNKNOWN;

      std::stringstream ss(x);
      std::string instTypeStr;
      ss >> instTypeStr;

      if(instTypeStr == "nop")
      {
        instType = InstructionType::NOP;
      }
      else if(instTypeStr == "acc")
      {
        instType = InstructionType::ACC;
      }
      else if(instTypeStr == "jmp")
      {
        instType = InstructionType::JMP;
      }

      return instType;
    }

    std::string UTILITIES_EXPORT InstructionTypeToString(const InstructionType x)
    {
      std::string s;

      switch(x)
      {
      case InstructionType::NOP:
        s = "nop";
        break;
      case InstructionType::ACC:
        s = "acc";
        break;
      case InstructionType::JMP:
        s = "jmp";
        break;
      default:
        break;
      }

      return s;
    }

    int UTILITIES_EXPORT StringToInstructionOffset(const std::string& x)
    {
      std::stringstream ss(x);
      std::string throwAway;
      ss >> throwAway;

      int offset;
      ss >> offset;

      return offset;
    }

    bool UTILITIES_EXPORT GetDoesProgramTerminate(const std::vector<std::string>& x)
    {
      size_t i = 0;
      std::vector<size_t> executedInstructions;
      while(i < x.size() && std::find(executedInstructions.begin(), executedInstructions.end(),
                                      i) == executedInstructions.end())
      {
        executedInstructions.push_back(i);

        const auto& instruction = x[i];
        const auto instType = StringToInstructionType(instruction);
        const auto instOffset = StringToInstructionOffset(instruction);
        switch(instType)
        {
          // Does nothing.
        case InstructionType::NOP:
          // Offsets accumulator.
        case InstructionType::ACC:
          ++i;
          break;
        case InstructionType::JMP:
          // Jumps to instruction.
          i += instOffset;
          break;
        default:
          std::cerr << "Could not translate instruction: " << instruction << ", " << i << std::endl;
          std::exit(EXIT_FAILURE);
          break;
        }
      }

      return i == x.size();
    }

    int UTILITIES_EXPORT GetFinalAccumulator(const std::vector<std::string>& x)
    {
      int accumulator = 0;
      size_t i = 0;
      std::vector<size_t> executedInstructions;
      while(i < x.size() && std::find(executedInstructions.begin(), executedInstructions.end(),
                                      i) == executedInstructions.end())
      {
        executedInstructions.push_back(i);

        const auto& instruction = x[i];
        const auto instType = util::day08::StringToInstructionType(instruction);
        const auto instOffset = util::day08::StringToInstructionOffset(instruction);
        switch(instType)
        {
        case util::day08::InstructionType::ACC:
          accumulator += instOffset;
        case util::day08::InstructionType::NOP:
          ++i;
          break;
        case util::day08::InstructionType::JMP:
          i += instOffset;
          break;
        default:
          std::cerr << "Could not translate instruction: " << instruction << "\n";
          std::exit(EXIT_FAILURE);
          break;
        }
      }

      return accumulator;
    }
  } // namespace day08
} // namespace util
