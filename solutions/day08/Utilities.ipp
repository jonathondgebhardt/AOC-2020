#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>

namespace util
{
  namespace day08
  {
    enum UTILITIES_EXPORT InstructionType
    {
      UNKNOWN = 0,
      NOP,
      ACC,
      JMP
    };

    InstructionType UTILITIES_EXPORT StringToInstructionType(const std::string& x)
    {
      auto instType = InstructionType::UNKNOWN;

      std::stringstream ss(x);
      std::string instTypeStr;
      ss >> instTypeStr;

      if(instTypeStr == "nop")
      {
        instType = InstructionType::NOP;
      }
      else if(instTypeStr == "acc")
      {
        instType = InstructionType::ACC;
      }
      else if(instTypeStr == "jmp")
      {
        instType = InstructionType::JMP;
      }

      return instType;
    }

    std::string UTILITIES_EXPORT InstructionTypeToString(const InstructionType x)
    {
      std::string s;

      switch(x)
      {
      case InstructionType::NOP:
        s = "nop";
        break;
      case InstructionType::ACC:
        s = "acc";
        break;
      case InstructionType::JMP:
        s = "jmp";
        break;
      default:
        break;
      }

      return s;
    }

    int UTILITIES_EXPORT StringToInstructionOffset(const std::string& x)
    {
      std::stringstream ss(x);
      std::string throwAway;
      ss >> throwAway;

      int offset;
      ss >> offset;

      return offset;
    }

    bool UTILITIES_EXPORT GetDoesProgramTerminate(const std::vector<std::string>& x)
    {
      size_t i = 0;
      std::vector<size_t> executedInstructions;
      while(i < x.size() && std::find(executedInstructions.begin(), executedInstructions.end(),
                                      i) == executedInstructions.end())
      {
        executedInstructions.push_back(i);

        const auto& instruction = x[i];
        const auto instType = StringToInstructionType(instruction);
        const auto instOffset = StringToInstructionOffset(instruction);
        switch(instType)
        {
        case InstructionType::NOP:
        case InstructionType::ACC:
          ++i;
          break;
        case InstructionType::JMP:
          i += instOffset;
          break;
        default:
          std::cerr << "Could not translate instruction: " << instruction << ", " << i << std::endl;
          break;
        }
      }

      return i == x.size();
    }

    int UTILITIES_EXPORT GetFinalAccumulator(const std::vector<std::string>& x)
    {
      int accumulator = 0;
      size_t i = 0;
      std::vector<size_t> executedInstructions;
      while(i < x.size() && std::find(executedInstructions.begin(), executedInstructions.end(),
                                      i) == executedInstructions.end())
      {
        executedInstructions.push_back(i);

        const auto& instruction = x[i];
        const auto instType = StringToInstructionType(instruction);
        const auto instOffset = StringToInstructionOffset(instruction);
        switch(instType)
        {
        case InstructionType::ACC:
          accumulator += instOffset;
        case InstructionType::NOP:
          ++i;
          break;
        case InstructionType::JMP:
          i += instOffset;
          break;
        default:
          std::cerr << "Could not translate instruction: " << instruction << "\n";
          break;
        }
      }

      return accumulator;
    }

    std::string UTILITIES_EXPORT InvertInstruction(const std::string& x)
    {
      const auto instType = StringToInstructionType(x);

      std::string instTypeStr;
      switch(instType)
      {
      case InstructionType::NOP:
        instTypeStr = InstructionTypeToString(InstructionType::JMP);
        break;
      case InstructionType::JMP:
        instTypeStr = InstructionTypeToString(InstructionType::NOP);
        break;
      case InstructionType::ACC:
      default:
        break;
      }

      const auto instOffset = StringToInstructionOffset(x);

      return instTypeStr + " " + std::to_string(instOffset);
    }
  } // namespace day08
} // namespace util
