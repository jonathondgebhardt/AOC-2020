#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>
#include <cassert>
#include <numeric>
#include <ostream>

namespace util
{
  namespace day16
  {
    struct UTILITIES_EXPORT Rule
    {
      typedef std::vector<std::pair<size_t, size_t>> Fields;
      Fields fields;
      std::string fieldName;

      explicit Rule(const Fields& fields, const std::string& fieldName)
          : fields(fields), fieldName(fieldName)
      {
      }

      bool getIsValid(size_t value) const
      {
        return std::any_of(this->fields.begin(), this->fields.end(),
                           [value](std::pair<size_t, size_t> bounds) {
                             return value >= bounds.first && value <= bounds.second;
                           });
      }

      void dump(std::ostream& os) const
      {
        for(const auto field : this->fields)
        {
          os << field.first << ", " << field.second << "\n";
        }

        os << "\n";
      }
    };

    std::vector<Rule> GetRules(const std::vector<std::string>& x)
    {
      std::vector<Rule> rules;

      const auto getRange = [](const std::string& x) -> std::pair<size_t, size_t> {
        const auto hyphenIndex = x.find('-');
        if(hyphenIndex == std::string::npos)
        {
          assert(hyphenIndex != std::string::npos);
        }

        const auto lb = util::StringTo<size_t>(x.substr(0, hyphenIndex)).value_or(-1);
        const auto ub = util::StringTo<size_t>(x.substr(hyphenIndex + 1)).value_or(-1);
        assert(lb != -1 && ub != -1);

        return std::make_pair(lb, ub);
      };

      // Rules are first in the input file.
      for(const auto& line : x)
      {
        // "your ticket" starts after a new line following the rules.
        if(line.empty())
        {
          break;
        }

        const auto colonIndex = line.find(":");
        assert(colonIndex != std::string::npos);

        const auto tokens = util::Split(line.substr(colonIndex + 2), ' ');
        const auto& firstRange = tokens[0];
        const auto& secondRange = tokens[2];

        Rule r({getRange(firstRange), getRange(secondRange)}, line.substr(0, colonIndex));
        rules.push_back(r);
      }

      return rules;
    }

    typedef std::vector<size_t> Ticket;

    std::vector<Ticket> GetNearbyTickets(const std::vector<std::string>& x)
    {
      std::vector<Ticket> tickets;

      const auto foundIt = std::find(x.begin(), x.end(), "nearby tickets:");
      assert(foundIt != x.end());

      for(auto it = foundIt + 1; it != x.end(); it++)
      {
        const auto tokens = util::Split(*it, ',');

        Ticket t;
        std::transform(tokens.begin(), tokens.end(), std::back_inserter(t),
                       [](const std::string& x) { return util::StringTo<size_t>(x).value(); });

        tickets.push_back(t);
      }

      return tickets;
    }

    struct UTILITIES_EXPORT TicketMaster
    {
      std::vector<Ticket> tickets;
      std::vector<Rule> rules;

      TicketMaster(const std::vector<Rule>& rules, const std::vector<Ticket> tickets)
          : rules(rules), tickets(tickets)
      {
      }

      size_t getSumOfInvalidFields() const
      {
        size_t sum = 0;

        for(const auto ticket : this->tickets)
        {
          sum += std::transform_reduce(
              ticket.begin(), ticket.end(), 0, std::plus<size_t>(), [this](size_t value) {
                if(std::none_of(this->rules.begin(), this->rules.end(),
                                [value](const Rule& rule) { return rule.getIsValid(value); }))
                {
                  return value;
                }

                return size_t(0);
              });
        }

        return sum;
      }
    };

  } // namespace day16
} // namespace util
