#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>
#include <cmath>
#include <unordered_map>

namespace util
{
  namespace day15
  {
    std::vector<size_t> UTILITIES_EXPORT GetStartingNumbers(const std::vector<std::string>& x)
    {
      std::vector<size_t> startingNumbers;

      const auto& first = x.front();
      const auto tokens = util::Split(first, ',');

      std::transform(tokens.begin(), tokens.end(), std::back_inserter(startingNumbers),
                     [](const std::string& x) { return util::StringTo<size_t>(x).value(); });

      return startingNumbers;
    }

    std::optional<size_t> UTILITIES_EXPORT GetLastTimeSpoken(std::unordered_map<size_t, size_t>& x,
                                                             size_t num)
    {
      std::optional<size_t> lastTime;

      const auto it = x.find(num);
      if(it != x.end())
      {
        lastTime = x[num];
      }

      return lastTime;
    }

    size_t UTILITIES_EXPORT GetNthWordSpoken(const std::vector<size_t>& x, size_t n)
    {
      std::unordered_map<size_t, size_t> words;
      for(size_t i = 0; i < x.size(); ++i)
      {
        words[x[i]] = i + 1;
      }

      size_t turn = x.size() + 1;
      auto lastNumSpoken = x.back();
      auto lastTurnSpoken = x.size();
      while(turn <= n)
      {
        if(lastTurnSpoken == words[lastNumSpoken])
        {
          lastNumSpoken = 0;
        }
        else
        {
          lastNumSpoken = words[lastNumSpoken] - lastTurnSpoken;
        }

        if(words.find(lastNumSpoken) == words.end())
        {
          words[lastNumSpoken] = turn;
        }

        lastTurnSpoken = words[lastNumSpoken];
        words[lastNumSpoken] = turn;

        ++turn;
      }

      return lastNumSpoken;
    }
  } // namespace day15
} // namespace util
