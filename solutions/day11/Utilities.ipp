#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>
#include <cassert>
#include <iterator>

namespace util
{
  namespace day11
  {
    struct UTILITIES_EXPORT OccupiedSeatAdapter
    {
      void dump(std::ostream& os) const
      {
        for(const auto& row : this->seats)
        {
          std::copy(row.begin(), row.end(), std::ostream_iterator<char>(os, " "));
          os << "\n";
        }

        os << "\n";
      }

      std::optional<bool> getIsSeat(size_t row, size_t col) const
      {
        if(row >= 0 && row < this->seats.size() && col >= 0 && this->seats[row].size())
        {
          return this->seats[row][col] != '.';
        }

        return std::nullopt;
      }

      virtual bool getShouldSit(int row, int col) const = 0;

      virtual bool getShouldStand(int row, int col) const = 0;

      virtual bool getIsSeatOccupied(size_t row, size_t col) const
      {
        assert(row >= 0 && row < this->seats.size());
        const auto rowOfSeats = this->seats[row];

        assert(col >= 0 && col < rowOfSeats.size());
        const auto seat = rowOfSeats[col];
        return seat == '#';
      }

      virtual std::optional<bool> checkUp(int row, int col) const = 0;

      virtual std::optional<bool> checkUpDiagonalLeft(int row, int col) const = 0;

      virtual std::optional<bool> checkUpDiagonalRight(int row, int col) const = 0;

      virtual std::optional<bool> checkLeft(int row, int col) const = 0;

      virtual std::optional<bool> checkRight(int row, int col) const = 0;

      virtual std::optional<bool> checkDown(int row, int col) const = 0;

      virtual std::optional<bool> checkDownDiagonalLeft(int row, int col) const = 0;

      virtual std::optional<bool> checkDownDiagonalRight(int row, int col) const = 0;

      size_t getOccupiedSeats(size_t row, size_t col) const
      {
        size_t occupiedSeats = 0;

        const auto upOpt = this->checkUp(row, col);
        if(upOpt.has_value() && upOpt.value())
        {
          ++occupiedSeats;
        }

        const auto upDLOpt = this->checkUpDiagonalLeft(row, col);
        if(upDLOpt.has_value() && upDLOpt.value())
        {
          ++occupiedSeats;
        }

        const auto upDROpt = this->checkUpDiagonalRight(row, col);
        if(upDROpt.has_value() && upDROpt.value())
        {
          ++occupiedSeats;
        }

        const auto leftOpt = this->checkLeft(row, col);
        if(leftOpt.has_value() && leftOpt.value())
        {
          ++occupiedSeats;
        }

        const auto rightOpt = this->checkRight(row, col);
        if(rightOpt.has_value() && rightOpt.value())
        {
          ++occupiedSeats;
        }

        const auto downOpt = this->checkDown(row, col);
        if(downOpt.has_value() && downOpt.value())
        {
          ++occupiedSeats;
        }

        const auto downDLOpt = this->checkDownDiagonalLeft(row, col);
        if(downDLOpt.has_value() && downDLOpt.value())
        {
          ++occupiedSeats;
        }

        const auto downDROpt = this->checkDownDiagonalRight(row, col);
        if(downDROpt.has_value() && downDROpt.value())
        {
          ++occupiedSeats;
        }

        return occupiedSeats;
      }

      std::vector<std::vector<char>> seats;
    };

    struct UTILITIES_EXPORT WaitingArea
    {
      explicit WaitingArea(const std::vector<std::string>& seats)
      {
        for(const auto& row : seats)
        {
          std::vector<char> rowC;
          std::copy(row.begin(), row.end(), std::back_inserter(rowC));

          this->seats.push_back(rowC);
        }
      }

      void dump(std::ostream& os) const
      {
        os << "Round " << this->rounds << " (" << this->getOccupiedSeats() << "):\n";
        for(const auto& row : this->seats)
        {
          std::copy(row.begin(), row.end(), std::ostream_iterator<char>(os, " "));
          os << "\n";
        }

        os << "\n";
      }

      void invertSeat(size_t row, size_t col, const OccupiedSeatAdapter& osa)
      {
        if(this->seats[row][col] != '.')
        {
          this->seats[row][col] = osa.getIsSeatOccupied(row, col) ? 'L' : '#';
        }
      }

      template <typename T> void startNewRound(T osa)
      {
        osa.seats = this->seats;

        this->seatsChanged = false;
        this->rounds++;

        for(size_t i = 0; i < this->seats.size(); ++i)
        {
          for(size_t j = 0; j < this->seats[i].size(); ++j)
          {
            // Skip empty spots.
            if(this->seats[i][j] == '.')
            {
              continue;
            }

            if(osa.getShouldSit(i, j) || osa.getShouldStand(i, j))
            {
              this->invertSeat(i, j, osa);
              this->seatsChanged = true;
            }
          }
        }
      }

      size_t getOccupiedSeats() const
      {
        size_t occupiedSeats = 0;

        for(const auto& row : this->seats)
        {
          occupiedSeats += std::count(row.begin(), row.end(), '#');
        }

        return occupiedSeats;
      }

      bool getSeatsChanged() const { return this->seatsChanged; }

      size_t getRounds() const { return this->rounds; }

      std::vector<std::vector<char>> seats;
      bool seatsChanged{false};
      size_t rounds{0};
    };
  } // namespace day11
} // namespace util
