#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>
#include <numeric>

namespace util
{
  namespace day10
  {
    std::vector<size_t> GetJoltages(const std::vector<std::string>& x)
    {
      std::vector<size_t> joltages;

      // According to the prompt, 0 is implied but not included in the input file.
      joltages.push_back(0);

      std::transform(x.begin(), x.end(), std::back_inserter(joltages),
                     [](std::string xStr) { return util::StringTo<size_t>(xStr).value(); });

      std::sort(joltages.begin(), joltages.end());

      // According to the prompt, (largest joltage + 3) is implied but not included in the input
      // file.
      if(!joltages.empty())
      {
        joltages.push_back(joltages.back() + 3);
      }

      return joltages;
    }

    std::vector<size_t> GetJoltageDeltas(const std::vector<size_t>& x)
    {
      std::vector<size_t> deltas;

      for(auto it = x.begin() + 1; it != x.end(); it++)
      {
        deltas.push_back(*it - *(it - 1));
      }

      return deltas;
    }

    std::optional<size_t> GetIndexToRemove(const std::vector<size_t>& x, size_t offset = 0)
    {
      std::optional<size_t> index;

      for(auto it = x.begin() + offset; it != x.end() && !index.has_value(); it++)
      {
        if(*it < 3)
        {
          const auto next = it + 1;
          if(next != x.end() && *it + *next <= 3)
          {
            index = std::distance(x.begin(), next);
          }
        }
      }

      return index;
    }

  } // namespace day10
} // namespace util
