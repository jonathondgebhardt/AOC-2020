#include <day10/Utilities.ipp>

#include <algorithm>
#include <cmath>

// File auto-generated by StartNewDay

int main(int argc, char* argv[])
{
  const auto fileName = util::GetInputFile("day10.txt");
  const auto contents = util::Parse(fileName);

  const auto joltages = util::day10::GetJoltages(contents);
  const auto deltas = util::day10::GetJoltageDeltas(joltages);

  // pair.first: joltage
  // pair.second: joltage difference to next joltage
  std::vector<std::pair<size_t, size_t>> joltageDeltas;
  for(size_t i = 0; i < deltas.size(); ++i)
  {
    joltageDeltas.push_back(std::make_pair(joltages[i], deltas[i]));
  }

  joltageDeltas.push_back(std::make_pair(joltages.back(), 0));

  size_t combinations = 1;

  // This is a feels bad. There are clearly better ways to do this but this is a solution with very
  // minimal hints.
  for(size_t i = 0; i < joltageDeltas.size(); ++i)
  {
    auto jd = joltageDeltas[i];
    if(jd.second == 1)
    {
      util::day10::JoltageCombination jc;

      // Get the beginning of the range.
      jc.beginJoltage = jd.first;

      // Grab no more than three joltages with deltas equal to one.
      for(size_t j = i + 1; jc.joltages.size() < 3; ++j)
      {
        jc.joltages.push_back(joltageDeltas[j].first);

        if(joltageDeltas[j].second != 1)
        {
          break;
        }
      }

      // We need the next number in the list so we can make sure we're making valid combinations.
      jc.endJoltage = joltageDeltas[jc.joltages.size() + i + 1].first;

      const auto validCombos = util::day10::GetValidCombinations(jc);
      if(validCombos > 0)
      {
        combinations *= validCombos;

        // Move up to the end voltage we checked to avoid counting combinations more than once.
        i += jc.joltages.size();
      }
    }
  }

  std::cout << combinations << "\n";

  return EXIT_SUCCESS;
}
