#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>

namespace util
{
  namespace day07
  {
    struct UTILITIES_EXPORT Bag
    {
      explicit Bag(const std::string& x) : type(x) {}

      bool operator=(const Bag& other) const { return this->type == other.type; }
      bool operator=(const std::string& otherType) const { return this->type == otherType; }

      bool hasChild(const Bag& other) const { return this->hasChild(other.type); }
      bool hasChild(const std::string& bagType) const
      {
        return std::any_of(
            this->children.begin(), this->children.end(),
            [&bagType](const std::pair<std::string, size_t>& x) { return x.first == bagType; });
      }

      void dump(std::ostream& os) const
      {
        os << this->type << ": \n";

        if(!this->children.empty())
        {
          for(const auto pair : this->children)
          {
            os << "\t" << pair.first << ": " << pair.second << "\n";
          }
        }
        else
        {
          os << "\tno bags\n";
        }

        os << "\n";
      }

      std::string type;
      std::vector<std::pair<std::string, size_t>> children;
    };

    Bag UTILITIES_EXPORT StringToBag(const std::string& x, const std::vector<Bag>& bags)
    {
      const auto bag =
          std::find_if(bags.begin(), bags.end(), [&](const Bag& other) { return other.type == x; });

      return *bag;
    }

    std::vector<Bag> UTILITIES_EXPORT MakeBags(const std::vector<std::string>& x)
    {
      std::vector<Bag> bags;

      for(const auto& line : x)
      {
        const auto bagsIndex = line.find(" bags");
        Bag b(line.substr(0, bagsIndex));

        const std::string containToken = "contain ";
        const auto containIndex = line.find(containToken);
        auto xSubStr = line.substr(containIndex + containToken.size());

        std::stringstream lineStream(xSubStr);
        std::string s;
        while(std::getline(lineStream, s, ',') && s != "no other bags.")
        {
          std::stringstream ss(s);

          size_t numChildren;
          ss >> numChildren;

          std::string qualifier1;
          std::string qualifier2;
          ss >> qualifier1 >> qualifier2;
          std::string bagType = qualifier1 + " " + qualifier2;

          b.children.push_back(std::make_pair(bagType, numChildren));
        }

        bags.push_back(b);
      }

      return bags;
    }

    bool UTILITIES_EXPORT GetCanHoldBag(const Bag& rootBag, const Bag& desiredBag,
                                        const std::vector<Bag>& bags)
    {
      if(rootBag.hasChild(desiredBag))
      {
        return true;
      }

      return std::any_of(rootBag.children.begin(), rootBag.children.end(),
                         [&](const std::pair<std::string, size_t>& child) {
                           const auto bag = StringToBag(child.first, bags);
                           return GetCanHoldBag(bag, desiredBag, bags);
                         });
    }

    size_t UTILITIES_EXPORT GetRequiredBagsWithin(const Bag& rootBag, const std::vector<Bag>& bags)
    {
      if(rootBag.children.empty())
      {
        return 0;
      }

      size_t requiredBags = 0;
      for(const auto& child : rootBag.children)
      {
        requiredBags += child.second;

        const auto bag = StringToBag(child.first, bags);
        requiredBags += child.second * GetRequiredBagsWithin(bag, bags);
      }

      return requiredBags;
    }
  } // namespace day07
} // namespace util
