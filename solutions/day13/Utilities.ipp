#pragma once

// File auto-generated by StartNewDay

#include <Export.hpp>
#include <Utilities.ipp>

#include <algorithm>

namespace util
{
  namespace day13
  {
    struct UTILITIES_EXPORT Bus
    {
      bool operator<(Bus& other) { return this->departureTime < other.departureTime; }

      void dump(std::ostream& os)
      {
        os << "Bus Id: " << this->busId << ", closest time: " << this->departureTime << "\n";
      }

      size_t busId;
      size_t departureTime;
    };

    size_t UTILITIES_EXPORT GetEarliestTimeToDepart(const std::vector<std::string>& x)
    {
      if(!x.empty())
      {
        const auto first = x.front();
        const auto opt = util::StringTo<size_t>(first);
        if(opt.has_value())
        {
          return opt.value();
        }
      }

      return 0;
    }

    std::vector<Bus> GetBuses(const std::vector<std::string>& x, size_t departureTime)
    {
      std::vector<Bus> buses;

      if(x.size() > 1)
      {
        const auto tokens = util::Split(x[1], ',');
        for(const auto& t : tokens)
        {
          const auto busIdOpt = util::StringTo<size_t>(t);
          if(busIdOpt.has_value() && busIdOpt.value() != 0)
          {
            const auto time = busIdOpt.value();

            Bus b;
            b.busId = time;

            auto earliestTime = (departureTime / time) * time + time;
            b.departureTime = earliestTime;

            buses.push_back(b);
          }
        }
      }

      return buses;
    }

    size_t GetLowestTimeToWait(std::vector<Bus> buses, size_t departureTime)
    {
      std::sort(buses.begin(), buses.end());
      const auto firstBus = buses.front();

      return firstBus.busId * (firstBus.departureTime - departureTime);
    }

  } // namespace day13
} // namespace util
